{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { connect as connectX } from 'react-redux';\nimport { RootStore } from \"./config\";\nimport { valueExtractor } from \"./depth\";\nvar errors = {\n  xSetState: 'Provided state is not an object',\n  getStateForKey: 'getStateForKey: Giving key must be string!',\n  connectWrapped: 'WrappedComponent is required',\n  requiredKeysArray: 'required keys is not an Array',\n  requiredKeysStrings: 'all required keys should be strings'\n};\n\nvar xResetState = function xResetState() {\n  return setStateForKey('xResetState', null);\n};\n\nvar xSetState = function xSetState(state) {\n  if (typeof state !== 'object') {\n    console.warn(errors.xSetState);\n    return;\n  }\n\n  for (var key in state) {\n    setStateForKey(key, state[key]);\n  }\n};\n\nvar getStateForKey = function getStateForKey(key) {\n  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (typeof key !== 'string') {\n    console.warn(errors.getStateForKey);\n    return null;\n  }\n\n  var _RootStore$getState = RootStore.getState(),\n      RN = _RootStore$getState.RN;\n\n  var value = valueExtractor(RN, key);\n  return value || fallback;\n};\n\nvar setStateForKey = function setStateForKey(key, state) {\n  RootStore.dispatch({\n    type: key,\n    payload: state\n  });\n};\n\nvar connect = function connect(WrappedComponent) {\n  var requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var deepKeyReplacer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '_';\n\n  if (typeof WrappedComponent === 'undefined') {\n    throw Error(errors.connectWrapped);\n  }\n\n  var errorTemplate = function errorTemplate(reason) {\n    return \"ReactNativeRedux.connect\\nFailed to connect \\\"\" + WrappedComponent.name + \"\\\"\\nReason: \" + reason;\n  };\n\n  if (!Array.isArray(requiredKeys)) {\n    throw Error(errorTemplate(errors.requiredKeysArray));\n  }\n\n  var allStrings = requiredKeys.every(function (key) {\n    return typeof key === 'string';\n  });\n\n  if (!allStrings) {\n    throw Error(errorTemplate(errors.requiredKeysStrings));\n  }\n\n  var mapStateToProps = function mapStateToProps(_ref) {\n    var RN = _ref.RN;\n    var propsToConnect = {};\n\n    if (requiredKeys.length === 0) {\n      for (var key in RN) {\n        if (key !== 'didInit') {\n          propsToConnect[key] = RN[key];\n        }\n      }\n\n      return propsToConnect;\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(requiredKeys), _step; !(_step = _iterator()).done;) {\n      var _key = _step.value;\n\n      var isDeepKey = _key.includes('.');\n\n      var propKey = isDeepKey ? _key.split('.').join(deepKeyReplacer) : _key;\n      propsToConnect[propKey] = valueExtractor(RN, _key);\n    }\n\n    return propsToConnect;\n  };\n\n  return connectX(mapStateToProps, {})(WrappedComponent);\n};\n\nexport { connect, xSetState, xResetState, setStateForKey, getStateForKey };","map":{"version":3,"sources":["D:/Repos/iWallet/iwallet/node_modules/react-native-redux/src/methods.tsx"],"names":["connect","connectX","RootStore","valueExtractor","errors","xSetState","getStateForKey","connectWrapped","requiredKeysArray","requiredKeysStrings","xResetState","setStateForKey","state","console","warn","key","fallback","getState","RN","value","dispatch","type","payload","WrappedComponent","requiredKeys","deepKeyReplacer","Error","errorTemplate","reason","name","Array","isArray","allStrings","every","mapStateToProps","propsToConnect","length","isDeepKey","includes","propKey","split","join"],"mappings":"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","sourcesContent":["import { connect as connectX } from 'react-redux';\nimport { RootStore } from './config';\nimport { valueExtractor } from './depth';\n\nconst errors = {\n    xSetState: 'Provided state is not an object',\n    getStateForKey: 'getStateForKey: Giving key must be string!',\n    connectWrapped: 'WrappedComponent is required',\n    requiredKeysArray: 'required keys is not an Array',\n    requiredKeysStrings: 'all required keys should be strings',\n};\n\n/**\n * Reset State - Clears stored state tree.\n */\nconst xResetState = () => setStateForKey('xResetState', null);\n/**\n * X Set State\n * @param {object} state\n */\nconst xSetState = (state: object) => {\n    if (typeof state !== 'object') {\n        console.warn(errors.xSetState);\n        return;\n    }\n    for (const key in state) { setStateForKey(key, state[key]); }\n};\n\n/**\n    * Get State for Keys and subkeys (\"key.subkey\")\n    * @example\n    * // Get userData Object (key)\n    * const userData = getStateForKey('userData')\n    *\n    * // Get user's name from userData Object (Subkey)\n    * const userName = getStateForKey('userData.name')\n    * @param {string} key Key for required state\n */\nconst getStateForKey = (key: string, fallback = null) => {\n    if (typeof key !== 'string') {\n        console.warn(errors.getStateForKey);\n        return null;\n    }\n    const { RN } = RootStore.getState();\n    const value = valueExtractor(RN, key);\n    return value || fallback;\n};\n\n/**\n * Similar to xSetState, plus it can be used to set deep state\n */\nconst setStateForKey = (key: string, state: any) => {\n    RootStore.dispatch({ type: key, payload: state });\n};\n\n/**\n * React Component Connector\n * @param WrappedComponent Class Component\n * @param {Array<string>} requiredKeys Array Of required keys to be connected.\n */\nconst connect = (\n    WrappedComponent,\n    requiredKeys: Array<string> = [],\n    deepKeyReplacer: string = '_'\n) => {\n\n    if (typeof WrappedComponent === 'undefined') { throw Error(errors.connectWrapped); }\n\n    const errorTemplate = (reason: string) =>\n        `ReactNativeRedux.connect\\nFailed to connect \"${WrappedComponent.name}\"\\nReason: ${reason}`;\n\n    if (!Array.isArray(requiredKeys)) { throw Error(errorTemplate(errors.requiredKeysArray)); }\n\n    const allStrings = requiredKeys.every((key) => typeof key === 'string');\n    if (!allStrings) {\n        throw Error(errorTemplate(errors.requiredKeysStrings));\n    }\n    const mapStateToProps = ({ RN }) => {\n        const propsToConnect = {};\n        if (requiredKeys.length === 0) {\n            for (const key in RN) {\n                if (key !== 'didInit') { propsToConnect[key] = RN[key]; }\n            }\n            return propsToConnect;\n        }\n        for (const key of requiredKeys) {\n            const isDeepKey = key.includes('.');\n            const propKey = isDeepKey ? key.split('.').join(deepKeyReplacer) : key;\n            propsToConnect[propKey] = valueExtractor(RN, key);\n        }\n        return propsToConnect;\n    };\n    return connectX(mapStateToProps, {})(WrappedComponent);\n};\n\n\nexport {\n    connect,\n    xSetState, xResetState,\n    setStateForKey, getStateForKey,\n};\n"]},"metadata":{},"sourceType":"module"}